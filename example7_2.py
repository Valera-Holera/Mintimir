# example7_2
import numpy as np
import run_kut4
import math
import euler
import matplotlib.pyplot as plt


# Общий вид дифференциального уравнения первого порядка:
# y' = f(x,y)
# Решение этого уравнения содержит произвольную константу (константу
# интегрирования). Чтобы найти эту константу, мы должны знать точку на
# кривой решения; то есть y должен быть указан при некотором значении х,
# скажем, при х = а. Запишем это вспомогательное условие в виде:
# y(a) = α
# Обыкновенное дифференциальное уравнение порядка n:
# y(n) = f(x,y,y',y'',y''',...,y(n-1))
# его можно преобразовать в n уравнений первого порядка, используем замену:
# y[0]=y, y[1]=y', y[2]=y'',..., y[n-1]=y(n-1)
# Эквивалентные уравнения первого порядка:
# y'[0]=y[1], y'[1]=y[2], y'[2]=y[3],..., y'[n]=f(x,y[0], y[1],..., y[n-1])
#
# Решение теперь требует знания n вспомогательных условий. Если эти условия
# заданы при одном и том же значении x, говорят, что это initial value
# problem. Тогда начальные условия имеют вид:
# y[0](α)=α[0], y[1](α)=α[1],..., y[n-1](α)=α[n-1]
# Если y[i] заданы при разных x, то это boundary value problem.
# В этой главе рассматриваются только initial value problems, так как
# bounndary более сложны для решения. Также мы будем использовать
# векторную запись уравнений:
# _    _    _   _      _
# y' = F(x, y), y(a) = α
# где:
# _    _
# F(x, y) =| y[1] |
#          | y[2] |
#          |  .   |
#          |  .   |
#          |  .   |
#          |f(x,y)|


def F(x, y):
    F = np.zeros(1)
    F[0] = x ** 2 - 4 * y[0]
    return F


def F1(x, y):
    F1 = np.zeros(2)
    F1[0] = y[1]
    F1[1] = (-0.1) * y[1] - x
    return F1


x = 0.0  # Start of integration
xStop = 10.0  # End of integration
y = np.array([0.0, 1.0])  # Initial values of {y}
h = 0.25  # Step size
X, Y = run_kut4.integrate(F1, x, y, xStop, h)
yExact = 100 * X - 5 * X ** 2 + 990 * (np.exp((-0.1) * X) - 1)
# for x in range(0,10, 0.25):
#    yExact[i] = (31/32)*math.e**(-4*x)+(1/4)*x**2-(1/8)*x+1/32
plt.plot(X, Y[:, 0], 'o', X, yExact, '-')
plt.grid(True)
plt.xlabel('x')
plt.ylabel('y')
plt.legend(('Numerical', 'Exact'), loc=0)
plt.show()

print(Y[-1] - yExact[-1])
